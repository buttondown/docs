---
title: Creating a subscriber
endpoint: /subscribers
method: post
relatedPages: []
---
{% noticeInfo
   text="This endpoint is for creating a new subscriber via the API. If you're looking to just do this via the UI, [this doc](/manually-adding-subscribers) is for you." /%}

### Double opt-in

By default, newly created subscribers are subject to [double opt-in](/glossary-double-optin) — they will receive an email asking them to confirm their subscription, and have a state of [`unactivated`](/api-subscribers-type#unactivated) until they do so.

You can't disable this behavior globally, but you *can* disable it on a per-subscriber basis by providing a `type` of `regular` in the request body.

### Handling collisions and updates

By default, Buttondown tries to preserve existing subscriber data, even when you create a new subscriber with the same email address.

Consider the following example (of a pseudocode request), where we attempt to create the same subscriber twice, with different tags:

```shell
POST /v1/subscribers {
  "email_address": "john@example.com",
  "tags": ["tag-1", "tag-2"]
} # This will succeed, and return a 201 status code.

POST /v1/subscribers {
  "email_address": "john@example.com",
  "tags": ["tag-2", "tag-3"]
} # This will return a 400 status code, and the subscriber will not be created.
```

Here, Buttondown intentionally *rejects* the second request, because it would overwrite the existing subscriber's data.

Similarly, imagine that you create a subscriber with a `type` of `regular`. Time passes — the subscriber unsubscribes — and then they decide they want to re-subscribe.

```shell
POST /v1/subscribers {
  "email_address": "john@example.com",
  "type": "regular"
} # This will succeed, and return a 201 status code.

# ... time passes ...

POST /v1/subscribers {
  "email_address": "john@example.com",
  "type": "regular"
} # This will _fail_, and return a 400 status code.
```

Again, Buttondown intentionally *rejects* the second request, because it would overwrite the existing subscriber's data and any history (such as emails they engaged with, [surveys](/surveys) they completed, etc.).

The right way to model both of these scenarios would be to [update](/api-subscribers-update) the existing subscriber, rather than creating a new one altogether.

However, updating a subscriber is not necessarily feasible for all integrations. If you're looking for behavior more akin to an upsert, you can provide a `X-Buttondown-Collision-Behavior` header of `overwrite` or `add` in the request header:

```shell
curl -X POST https://api.buttondown.com/v1/subscribers \
  -H "X-Buttondown-Collision-Behavior: overwrite" \
  -H "Authorization: Bearer $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"email_address": "john@example.com", "tags": ["tag-1", "tag-2"]}'

curl -X POST https://api.buttondown.com/v1/subscribers \
  -H "X-Buttondown-Collision-Behavior: overwrite" \
  -H "Authorization: Bearer $API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"email_address": "john@example.com", "tags": ["tag-2", "tag-3"]}'
```

---
